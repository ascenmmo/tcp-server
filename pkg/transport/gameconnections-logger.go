// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"context"
	"github.com/ascenmmo/tcp-server/pkg/restconnection"
	"github.com/ascenmmo/tcp-server/pkg/restconnection/types"
	"github.com/ascenmmo/tcp-server/pkg/transport/viewer"
	"github.com/google/uuid"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"time"
)

type loggerGameConnections struct {
	next restconnection.GameConnections
}

func loggerMiddlewareGameConnections() MiddlewareGameConnections {
	return func(next restconnection.GameConnections) restconnection.GameConnections {
		return &loggerGameConnections{next: next}
	}
}

func (m loggerGameConnections) SetSendMessage(ctx context.Context, token string, message types.RequestSetMessage) (err error) {
	logger := log.Ctx(ctx).With().Str("service", "GameConnections").Str("method", "setSendMessage").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request": viewer.Sprintf("%+v", requestGameConnectionsSetSendMessage{
					Message: message,
					Token:   token,
				}),
				"response": viewer.Sprintf("%+v", responseGameConnectionsSetSendMessage{}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call setSendMessage")
			return
		}
		logger.Info().Func(logHandle).Msg("call setSendMessage")
	}(time.Now())
	return m.next.SetSendMessage(ctx, token, message)
}

func (m loggerGameConnections) GetMessage(ctx context.Context, token string) (messages types.ResponseGetMessage, err error) {
	logger := log.Ctx(ctx).With().Str("service", "GameConnections").Str("method", "getMessage").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request":  viewer.Sprintf("%+v", requestGameConnectionsGetMessage{Token: token}),
				"response": viewer.Sprintf("%+v", responseGameConnectionsGetMessage{Messages: messages}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getMessage")
			return
		}
		logger.Info().Func(logHandle).Msg("call getMessage")
	}(time.Now())
	return m.next.GetMessage(ctx, token)
}

func (m loggerGameConnections) RemoveUser(ctx context.Context, token string, userID uuid.UUID) (err error) {
	logger := log.Ctx(ctx).With().Str("service", "GameConnections").Str("method", "removeUser").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request": viewer.Sprintf("%+v", requestGameConnectionsRemoveUser{
					Token:  token,
					UserID: userID,
				}),
				"response": viewer.Sprintf("%+v", responseGameConnectionsRemoveUser{}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call removeUser")
			return
		}
		logger.Info().Func(logHandle).Msg("call removeUser")
	}(time.Now())
	return m.next.RemoveUser(ctx, token, userID)
}
